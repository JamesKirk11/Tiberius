##################################################################################################
#### The master input file used by gppm_fit.py, pm_fit.py, plot_output.py and generate_LDCS.py #####
##################################################################################################


### INPUT FILES

# Critical inputs
time_file =  # a path that points to a pickled numpy array of times.
flux_file =	#  a path that points to a pickled numpy array of fluxes. If this is for a white light curve it should have shape (1,). Otherwise for wavelength-binned fits, it should have shape = (nbins,nfluxes)
error_file = #  a path that points to a pickled numpy array of fluxes. If this is for a white light curve it should have shape (1,). Otherwise for wavelength-binned fits, it should have shape = (nbins,nfluxes)

wvl_centres = 	# either a single number (in case of white light curve) OR a pickled numpy array of wavlength bin centres. 
wvl_bin_full_width =	# either a single number (in case of white light curve) OR a pickled numpy array of wavlength bin centres. This is the FULL WIDTH of the bin NOT the width/2.


# Ancillary inputs for detrending
model_input_files =  # paths that point to an arbitrary number of pickled arrays of detrending inputs. Each path needs to be separated by a comma, e.g.: "time.pickle,background.pickle,x.pickle,..."


### LIMB DARKENING; including whether we want priors and the parameters of the host star
generate_LDCs = 1 # do you want to generate LDCs? Set to 1 (on) or 0 (off).
LDCs_package = exotic-ld # Options: exotic-ld or LDTk

ld_law = quadratic # choose between linear/quadratic/squareroot/nonlinear/
use_generated_ld_uncertainties = 1 # do you want to use the unertainties from the generated LDCs? Set to 1 (on) or 0 (off).
ld_uncertainty_multiplier = 3 	# If wanting to inflate the error bars on the LDCs from the generated LDCs, set this to a factor. e.g. setting to 3, inflates errors by a factor of 3. Only used if use_generated_ld_uncertainties = 1.
use_kipping_parameterisation = 0	# Use if wanting to use Kipping's change of variables for efficient sampling of LDCs. NOTE: NOT FULLY TESTED. Set to 1 (on) or 0 (off).

# Stellar parameters, for limb darkening coefficients
Teff = 			# Stellar effective temperature in K
Teff_err = 		# Error in stellar effective temperature, in K
logg_star = 	# log(g) of star
logg_star_err =  # error in  log(g) of star
FeH = 			# Fe/H of star
FeH_err = 		# error in Fe/H of star


### FITTING PARAMETERS

contact1 = 		# position of the first contact point in frame numbers. Used to define the out of transit data, if wanting to optimise GP hyperparams to out of transit data and/or renormalising flux to out-of-transit data.
contact4 = 		# position of the fourth contact point in frame numbers. Used to define the out of transit data, if wanting to optimise GP hyperparams to out of transit data and/or renormalising flux to out-of-transit data.

first_integration = 0 # this allows you to clip the first N integrations from your light curves. This uses Python indexing.
last_integration = -1 # this allows you to clip the last N integrations from your light curves. This uses Python indexing.

common_noise_model = 	# a path to a pickled common noise model. Leave blank if not wanting to perform a common mode correction
clip_outliers = 1		# do you want to clip outliers before fitting? Set to 1 (on) or 0 (off).
sigma_cut =  4           # choose the sigma cut level (e.g. 3 sigma, 4 sigma) can be a float
median_clip = 0      # define whether you want to clip the outliers using a running median (1) or using a transit light curve fit (0). Currently only implemented for TransitModelGPPM

normalise_inputs = 1	# do we want to normalise the ancillary data? This is done through (input - mean(input))/std(input).  Set to 1 (on) or 0 (off).

renorm_flux = 0 # do we want to renormalise the flux to give an out of transit median of unity? Set to 1 (on) or 0 (off).


## FOR PARAMETRIC MODELLING

polynomial_orders = 		 	# What order polynomials are being used to model the systematic model inputs? Can be left blank if not using a polynomial. Note the inputs are those defined in the above 'model_input_files' and so must have the same length. e.g. for 3 model input files, you could set polynomial_orders to 0,1,2 (which would be 0th order/ignored first model input, 1st order poly to second input, 2nd order poly to 3rd input)
polynomial_coefficients = 		# starting positions of polynomial coefficients. Can be left blank, in which case the code makes a guess.
exponential_ramp = 0 # do you want to use an exponential ramp in your fitting? If yes, set this to an integer >= 1, where the number sets the number of exponentials to use. If not wanting to use an exponential ramp, keep this as 0.
step_function = 0 # do you want to fit a step function (1) or not (0)? This can be used to fit e.g. mirror tilt events in JWST light curves
step_breakpoint = # if step_function = 1, use this to define the starting guess for the breakpoint of the step function (in units of integrations). Can be left blank if not using a step function

## FOR GP MODELLING

kernel_classes = 				# A list of kernel classes that we want to use, e.g. "ExpSquared,Matern32,..." If we don't want to use a GP (and only polynomials), leave this blank. This needs to be as long as the number of 'model_input_files'
white_noise_kernel = 1			# Use white noise kernel (1) or not (0)
typeII_maximum_likelihood = 0	# run typeII maximum likelihood? i.e. hold GP hyperparameters fixed to optimized values and run MCMC over mean model parameters. Set to 1 (on) or 0 (off).


max_A_multiplier = 100   # the upper bound on the amplitude of the GP, defined as this number multiplied by the out-of-transit variance in the data
min_A_multiplier = 0.01  # the lower bound on the amplitude of the GP, defined as this number multiplied by the out-of-transit variance in the data

dy_max_multiplier = 3  # the upper bound on the GP lengthscale defined per model_input_parameter, defined as this number X the maximum distance between data points
dy_min_multiplier = 1  # the lower bound on the GP lengthscale defined per model_input_parameter, defined as this number X the median distance between data points

min_WN_sigma = 1e-7   # the lower bound on the white noise std dev
max_WN_sigma = 1000e6  # the upper bound on the white noise std dev

reset_kernel_priors = 0 # a boolean that allows you to reset the priors on the kernel hyperparameters using the results from the optimisation to the out of transit data. If true (=1), then the new kernel priors will be uniform between 0.9 and 1.1X the optimised values.



## MCMC PARAMETERS

nwalkers =	20	# number of emcee walkers. Must be an even integer.
nsteps =  auto 		# number of emcee steps. Note, set this to "auto" if wanting to let the autocorrelation length automatically determine the length of the chains. Note: these will never run over 20,000 steps even it autocorrelation is not satisfied. ***Set to 0 if wanting to perform a Levernberg-Marquadt fit with no MCMC!***
nthreads = 	2	# number of threads. NOTE: sometimes multi-threading conks out.
prod_only = 0   # do you want to run a single MCMC run all the way through (1) or break this up into an initial chain, followed by a 'production' chain (0). The latter is the default and is necessary if not using a GP so that the photometric uncertainties can be rescaled
save_chain = 0 # do we want to save the chains to text files: yes (1) or no (0). If yes, this can take up a lot of storage
optimise_model = 	1		# optimise the model parameters using a Nelder-Mead algorithm before starting the MCMC? Set to 1 (on) or 0 (off).


## DYNESTY PARAMETERS
live_points = 50 
precision_crit = 1e-3


## Plotting
show_plots = 1 # Do you want to plot intermediate plots of the fit outputs? Set to 1 (on) or 0 (off).
rebin_data = 	# can choose to bin the data for purposes of plotting. set this number to number of bins desired. Can be left blank.


# PLANET PARAMETERS, NEEDED TO CALCULATE SCALE HEIGHT FOR TRANSMISSION SPECTRUM IN plot_output.py

rp = 	# planet's radius in Jupiter radii
rs = 	# star's radius in solar radii
logg =  # logg of the planet OR can define:
g = 	# surface gravity of planet (in m/s^2)
Teq = # equilibrium temperature of planet in K


